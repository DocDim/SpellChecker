Early history 

Hash maps
Hashtables can also be used in place of ternary search trees for mapping strings to values. However, hash maps also frequently use more memory than ternary search trees (but not as much as tries). Additionally, hash maps are typically slower at reporting a string that is not in the same data structure, because it must compare the entire string rather than just the first few characters. There is some evidence that shows ternary search trees running faster than hash maps.[1] Additionally, hash maps do not allow for many of the uses of ternary search trees, such as near-neighbor lookups.
The college was founded in 1893 as the Woman's College of Frederick by the Potomac Synod of the Reformed Church of the United States. Dr. Joseph Henry Apple, an educator from Pittsburgh, Pennsylvania, only 28 years of age at the time of his appointment, was named the college's first president. In this first year, eighty-three women enrolled, and were taught by eight faculty members in Winchester Hall, located on East Church Street in Frederick. Classes were offered in the liberal arts and music, as well as secretarial trades. In 1898, the first class graduated, with fourteen women earning Bachelor of Arts degrees. Over the next several years, courses in biology, economics, sociology, political science, and domestic science were added.

In 1897, the college received a 28-acre (110,000 m2) tract of land for its campus from Margaret Scholl Hood. In 1913, the Trustees of the Woman's College announced that the name of the Woman's College would be changed to Hood College, in honor of Mrs. Hood, who gave $25,000 to establish an endowment for the college, and who firmly believed in higher education for women. On January 18, 1913, Margaret Hood's will was filed for probate. In the will, she bequeathed an additional $30,000 to the Woman's College of Frederick provided that the college had changed its name to "Hood College". Part of this bequest was used to fund the 1914 construction of Alumnae Hall. Today, except for Brodbeck Hall, which was built in the 1860s and stood on the campus at its founding, Alumnae Hall remains the oldest building on the college's campus and serves as the central location for the college's administration, also housing the sociology and social work department. In 1915, the college began its move from its former location in Frederick City to its current campus.

In 1934, Joseph Henry Apple retired as the college's president, having served for 41 years. At his retirement, he was the oldest college president in continuous active service at a single institution in the United States.

The Hood College Historic District was listed on the National Register of Historic Places in 2002.The campus is within close walking distance of downtown Frederick. In 2010, Forbes named downtown Frederick one of America's best neighborhoods, and in 2013, Forbes published the results of a Farmers Insurance Group study naming the Bethesda–Gaithersburg–Frederick, Maryland area one of the most secure metro areas in which to live in the United States.

Research Proposal
Title: Enhancing interpretability of AI models for healthcare predictions using explainable AI (XAI): A case study on real-time blood glucose level forecasting in Type 2 diabetes

1.	Introduction 
Diabetes, particularly Type 2 Diabetes Mellitus (T2DM), is a growing global health concern, affecting millions worldwide. In fact, the global prevalence of type 2 diabetes is projected to increase to 7079 individuals per 100,000 by 2030, reflecting a continued rise across all regions of the world (Khan). Effective management of T2DM relies on continuous monitoring and timely intervention to maintain optimal blood glucose levels. Recent advancements in wearable sensors and continuous glucose monitoring (CGM) devices have enabled real-time glucose tracking. However, predicting future glucose levels accurately and making these predictions interpretable for patients and healthcare providers remains a challenge. This research aims to develop an Explainable AI (XAI)-powered real-time forecasting model to predict blood glucose levels for T2DM patients using time-series data.
2.	Problem Statement 
Despite the availability of deep learning-based glucose forecasting models, most operate as "black-box" systems, lacking interpretability. This limits their trustworthiness and adoption in clinical settings. The main research problem is to design a robust and interpretable AI model capable of accurately forecasting blood glucose levels in real-time while providing meaningful explanations to users.  

3.	Research Objectives
 Develop a real-time blood glucose level forecasting model for T2DM patients using time-series data.
 Implement Explainable AI (XAI) techniques to enhance model interpretability.
 Evaluate the performance of different forecasting models, including LSTMs, GRUs, and Transformers.
 Assess the impact of lifestyle factors (diet, physical activity, medication) on glucose predictions.
 Deploy the model in a real-time pipeline for practical usability.
4.	Research Questions
 How can Explainable AI (XAI) techniques improve the interpretability of healthcare prediction models?
 What are the trade-offs between model accuracy and interpretability?
 Which XAI method (SHAP, LIME, Explainable Boosting Machines) is best suited for medical decision-making?
 How do different stakeholders (doctors, patients, AI researchers) perceive AI-generated explanations?
5.	Methodology
5.1.	Data Collection
Publicly available datasets such as the DirecNet dataset, UCI Blood Glucose dataset, and OhioT1DM (if a Type 2 diabetes subset is available) will be utilized to train and validate the forecasting models. Additionally, real-time data streams from continuous glucose monitoring (CGM) devices, fitness trackers like Fitbit and Apple Watch, and manually logged data on meals and medications will be integrated. This combination of historical and real-time data will enhance the model’s ability to predict blood glucose levels accurately, accounting for lifestyle factors and physiological variations, ultimately improving personalized diabetes management and decision-making in healthcare applications.
5.2.	Data Preprocessing
Missing values will be handled using interpolation techniques to ensure data continuity and accuracy in blood glucose level forecasting. To prevent bias and enhance model performance, glucose readings will be normalized, standardizing values across different patients and conditions. Feature engineering will be applied to extract meaningful insights, incorporating time-based features, glucose trends, and external lifestyle factors such as diet, physical activity, and medication intake. These preprocessing steps will enhance the quality of input data, enabling the development of robust and reliable AI models for real-time blood glucose prediction in Type 2 diabetes management.
5.3.	 Model Development
Various time-series forecasting models will be compared to determine the most effective approach for real-time blood glucose level prediction. Traditional models such as ARIMA and XGBoost will be evaluated using engineered features to capture temporal patterns. Deep learning models, including LSTM, GRU, and CNN-LSTM hybrids, will be explored for their ability to handle sequential dependencies. Additionally, transformer-based architectures like Informer and the Time Series Transformer will be tested for their scalability and efficiency in processing long-range dependencies. A sliding window approach will be implemented to ensure real-time forecasting, optimizing the models for continuous glucose monitoring in Type 2 diabetes management. 
5.4.	Explainability Techniques
Explainable AI (XAI) techniques will be employed to enhance the interpretability of blood glucose level predictions. SHAP (Shapley Additive Explanations) will be used to quantify feature importance at different time steps, providing insights into which factors most influence glucose fluctuations. Attention mechanism visualization will highlight key time points that significantly impact predictions, making model decisions more transparent. Additionally, counterfactual explanations will be implemented to demonstrate how lifestyle modifications, such as reduced carbohydrate intake, could alter glucose levels. These techniques will improve trust in AI-driven forecasts, enabling patients and healthcare providers to make more informed diabetes management decisions.
5.5.	 Real-Time Deployment
Apache Kafka or MQTT will be used for real-time data streaming, ensuring seamless and efficient transmission of continuous glucose monitoring (CGM) data. The forecasting models will be deployed using TensorFlow Serving or AWS Lambda, enabling scalable and cloud-based predictions with low latency. To enhance usability, an interactive dashboard will be developed using Dash or Streamlit, allowing patients and healthcare providers to visualize glucose trends, model predictions, and explanations in real time. This end-to-end system will facilitate continuous monitoring, providing interpretable insights that support proactive decision-making for effective Type 2 diabetes management.
6.	Evaluation Metrics
The evaluation of the proposed real-time blood glucose forecasting model will be based on multiple key metrics to ensure accuracy, interpretability, efficiency, and usability. Prediction accuracy will be assessed using Root Mean Squared Error (RMSE) and Mean Absolute Percentage Error (MAPE) to quantify how closely the predicted glucose levels match actual values. Model interpretability will be evaluated through the fidelity of SHAP explanations, ensuring that feature importance aligns with medical knowledge, while expert assessments from healthcare professionals will validate the model’s transparency and usefulness in clinical decision-making. Real-time performance will be measured by analyzing the latency of the streaming pipeline and inference time per prediction to ensure the system meets the demands of real-time monitoring without excessive delays. Finally, user trust and usability will be assessed through survey-based evaluations from patients and doctors, gathering feedback on how well the model’s predictions and explanations aid in diabetes management. By integrating these evaluation criteria, the research aims to develop an AI-powered glucose forecasting system that is not only accurate and efficient but also interpretable and trustworthy, fostering its adoption in real-world healthcare applications for Type 2 diabetes management.
7.	Expected Contributions
This research will contribute to the field of AI-driven healthcare by developing a novel real-time blood glucose forecasting model specifically tailored for Type 2 diabetes management. The model will leverage Explainable AI (XAI) techniques to improve the interpretability of glucose predictions, making it easier for both patients and healthcare providers to understand the factors influencing blood sugar fluctuations. Additionally, the study will result in a fully deployable system capable of real-time data streaming and visualization, ensuring continuous monitoring and timely intervention. By integrating lifestyle factors such as diet, physical activity, and medication intake into the prediction framework, the research will provide valuable insights into how these elements impact blood glucose trends over time. This holistic approach will not only enhance the accuracy of AI-driven forecasting but also empower users with actionable information to optimize diabetes management. The findings from this research could serve as a foundation for future advancements in AI-driven personalized healthcare and diabetes management.

8.	Conclusion 
Overall, the study aims to establish a link between AI-based predictions and real-world applicability by creating a transparent, reliable, and practical solution that promotes usability in clinical settings. By leveraging Explainable AI techniques, the proposed solution will enhance trust among patients and healthcare providers. The outcome will be a deployable real-time system that provides both accurate predictions and actionable insights, ultimately improving diabetes management.

Ternary search tree

In computer science, a ternary search tree is a type of trie (sometimes called a prefix tree) where nodes are arranged in a manner similar to a binary search tree, but with up to three children rather than the binary tree's limit of two. Like other prefix trees, a ternary search tree can be used as an associative map structure with the ability for incremental string search. However, ternary search trees are more space efficient compared to standard prefix trees, at the cost of speed. Common applications for ternary search trees include spell-checking and auto-completion.

Description
Each node of a ternary search tree stores a single character, an object (or a pointer to an object depending on implementation), and pointers to its three children conventionally named equal kid, lo kid and hi kid, which can also be referred respectively as middle (child), lower (child) and higher (child).[1] A node may also have a pointer to its parent node as well as an indicator as to whether or not the node marks the end of a word.[2] The lo kid pointer must point to a node whose character value is less than the current node. The hi kid pointer must point to a node whose character is greater than the current node.[1] The equal kid points to the next character in the word. The figure below shows a ternary search tree with the strings "cute","cup","at","as","he","us" and "i":
As with other trie data structures, each node in a ternary search tree represents a prefix of the stored strings. All strings in the middle subtree of a node start with that prefix.

Operations
Insertion
Inserting a value into a ternary search can be defined recursively or iteratively much as lookups are defined. This recursive method is continually called on nodes of the tree given a key which gets progressively shorter by pruning characters off the front of the key. If this method reaches a node that has not been created, it creates the node and assigns it the character value of the first character in the key. Whether a new node is created or not, the method checks to see if the first character in the string is greater than or less than the character value in the node and makes a recursive call on the appropriate node as in the lookup operation. If, however, the key's first character is equal to the node's value then the insertion procedure is called on the equal kid and the key's first character is pruned away.[1] Like binary search trees and other data structures, ternary search trees can become degenerate depending on the order of the keys.[3][self-published source?] Inserting keys in alphabetical order is one way to attain the worst possible degenerate tree.[1] Inserting the keys in random order often produces a well-balanced tree.[1]

Search
To look up a particular node or the data associated with a node, a string key is needed. A lookup procedure begins by checking the root node of the tree and determining which of the following conditions has occurred. If the first character of the string is less than the character in the root node, a recursive lookup can be called on the tree whose root is the lo kid of the current root. Similarly, if the first character is greater than the current node in the tree, then a recursive call can be made to the tree whose root is the hi kid of the current node.[1] As a final case, if the first character of the string is equal to the character of the current node then the function returns the node if there are no more characters in the key. If there are more characters in the key then the first character of the key must be removed and a recursive call is made given the equal kid node and the modified key.[1] This can also be written in a non-recursive way by using a pointer to the current node and a pointer to the current character of the key.[1]

Deletion
The delete operation consists of searching for a key string in the search tree and finding a node, called firstMid in the below pseudocode, such that the path from the middle child of firstMid to the end of the search path for the key string has no left or right children. This would represent a unique suffix in the ternary tree corresponding to the key string. If there is no such path, this means that the key string is either fully contained as a prefix of another string, or is not in the search tree. Many implementations make use of an end of string character to ensure only the latter case occurs. The path is then deleted from firstMid.mid to the end of the search path. In the case that firstMid is the root, the key string must have been the last string in the tree, and thus the root is set to null after the deletion.

Running time
The running time of ternary search trees varies significantly with the input. Ternary search trees run best when given several similar strings, especially when those strings share a common prefix. Alternatively, ternary search trees are effective when storing a large number of relatively short strings (such as words in a dictionary).[1] Running times for ternary search trees are similar to binary search trees, in that they typically run in logarithmic time, but can run in linear time in the degenerate (worst) case. Further, the size of the strings must also be kept in mind when considering runtime. For example, in the search path for a string of length k, there will be k traversals down middle children in the tree, as well as a logarithmic number of traversals down left and right children in the tree. Thus, in a ternary search tree on a small number of very large strings the lengths of the strings can dominate the runtime.

Comparison to other data structures
Tries
While being slower than other prefix trees, ternary search trees can be better suited for larger data sets due to their space-efficiency.[1]

Hash maps
Hashtables can also be used in place of ternary search trees for mapping strings to values. However, hash maps also frequently use more memory than ternary search trees (but not as much as tries). Additionally, hash maps are typically slower at reporting a string that is not in the same data structure, because it must compare the entire string rather than just the first few characters. There is some evidence that shows ternary search trees running faster than hash maps.[1] Additionally, hash maps do not allow for many of the uses of ternary search trees, such as near-neighbor lookups.

DAFSAs (deterministic acyclic finite state automaton)
If storing dictionary words is all that is required (i.e., storage of information auxiliary to each word is not required), a minimal deterministic acyclic finite state automaton (DAFSA) would use less space than a trie or a ternary search tree. This is because a DAFSA can compress identical branches from the trie which correspond to the same suffixes (or parts) of different words being stored.

Uses
Ternary search trees can be used to solve many problems in which a large number of strings must be stored and retrieved in an arbitrary order. Some of the most common or most useful of these are below:

Anytime a trie could be used but a less memory-consuming structure is preferred.[1]
A quick and space-saving data structure for mapping strings to other data.[3]
To implement auto-completion.[2][self-published source?]
As a spell check.[5]
Near-neighbor searching (of which spell-checking is a special case).[1]
As a database especially when indexing by several non-key fields is desirable.[5]
In place of a hash table.[5]
In 1897, the college received a 28-acre (110,000 m2) tract of land for its campus from Margaret Scholl Hood. In 1913, the Trustees of the Woman's College announced that the name of the Woman's College would be changed to Hood College, in honor of Mrs. Hood, who gave $25,000 to establish an endowment for the college, and who firmly believed in higher education for women. On January 18, 1913, Margaret Hood's will was filed for probate. In the will, she bequeathed an additional $30,000 to the Woman's College of Frederick provided that the college had changed its name to "Hood College".
